{"version":3,"file":"gatsby-node.js","sources":["../src/types.ts","../src/gatsby-node.ts"],"sourcesContent":["import { PluginOptions as GatsbyPluginOptions, NodeInput, Node } from 'gatsby'\nimport { CreateOptions as FlexSearchCreateOptions } from 'flexsearch'\n\nexport interface PartialContext {\n  nodeModel: {\n    getNodeById: (input: { id: string; type?: string }) => Node\n  }\n}\n\nexport type IndexableDocument = Record<string, unknown>\n\nexport type Store = Record<string, unknown>\n\nexport enum NodeType {\n  LocalSearch = 'LocalSearch',\n}\n\nexport type Engine = 'flexsearch' | 'lunr'\n\nexport interface LocalSearchNodeInput extends NodeInput {\n  name: string\n  engine: Engine\n  index: string\n  store: Store\n}\n\ninterface NormalizerInput {\n  errors?: unknown\n  data?: unknown\n}\n\nexport interface PluginOptions extends GatsbyPluginOptions {\n  name: string\n  engine: Engine\n  engineOptions?: FlexSearchCreateOptions\n  ref?: string\n  index?: string[]\n  store?: string[]\n  query: string\n  normalizer: (input: NormalizerInput) => IndexableDocument[]\n}\n","import path from 'path'\nimport fs from 'fs'\nimport lunr from 'lunr'\nimport FlexSearch from 'flexsearch'\nimport {\n  GatsbyNode,\n  CreatePagesArgs,\n  CreateSchemaCustomizationArgs,\n} from 'gatsby'\nimport { pick } from 'lodash'\nimport { pascalCase } from 'pascal-case'\n\nimport {\n  IndexableDocument,\n  NodeType,\n  PluginOptions,\n  Store,\n  LocalSearchNodeInput,\n} from './types'\n\nconst DEFAULT_REF = 'id'\n\nconst msg = (input: string) => `gatsby-plugin-local-search - ${input}`\n\nconst createFlexSearchIndexExport = (\n  documents: IndexableDocument[],\n  pluginOptions: PluginOptions,\n): string => {\n  const { ref = DEFAULT_REF, index: indexFields, engineOptions } = pluginOptions\n\n  const index = FlexSearch.create<IndexableDocument>(engineOptions)\n\n  documents.forEach((doc) => {\n    const docFieldValues = Object.values(\n      indexFields ? pick(doc, indexFields) : doc,\n    )\n    // Using \"as number\" due to FlexSearch's types, but it could technically be\n    // a string as well.\n    index.add(doc[ref] as number, JSON.stringify(docFieldValues))\n  })\n\n  return index.export()\n}\n\nconst createLunrIndexExport = (\n  documents: IndexableDocument[],\n  pluginOptions: PluginOptions,\n): string => {\n  const { ref = DEFAULT_REF, index: indexFields } = pluginOptions\n\n  const fields =\n    indexFields ?? (documents.length > 0 ? Object.keys(documents[0]) : [])\n\n  const index = lunr(function () {\n    this.ref(ref)\n    fields.forEach((field) => this.field(field))\n    documents.forEach((doc) => this.add(doc))\n  })\n\n  return JSON.stringify(index)\n}\n\nconst createIndexExport = (\n  documents: IndexableDocument[],\n  pluginOptions: PluginOptions,\n  gatsbyContext: CreatePagesArgs,\n): string | void => {\n  const { reporter } = gatsbyContext\n  const { name, engine } = pluginOptions\n\n  switch (engine) {\n    case 'flexsearch':\n      return createFlexSearchIndexExport(documents, pluginOptions)\n\n    case 'lunr':\n      return createLunrIndexExport(documents, pluginOptions)\n\n    default:\n      reporter.error(\n        msg(\n          `The engine option for index \"${name}\" is invalid. It must be one of: flexsearch, lunr. The index will not be created.`,\n        ),\n      )\n  }\n}\n\n// Callback style is necessary since createPages cannot be async or return a\n// Promise. At least, that's what GatsbyNode['createNodes'] says.\nexport const createPages = async (\n  gatsbyContext: CreatePagesArgs,\n  pluginOptions: PluginOptions,\n): Promise<void> => {\n  const {\n    actions,\n    graphql,\n    reporter,\n    createNodeId,\n    createContentDigest,\n  } = gatsbyContext\n  const { createNode } = actions\n  const {\n    name,\n    engine,\n    ref = DEFAULT_REF,\n    store: storeFields,\n    query,\n    normalizer,\n  } = pluginOptions\n\n  const result = await graphql(query)\n\n  if (result.errors) {\n    reporter.error(\n      msg(\n        'The provided GraphQL query contains errors. The index will not be created.',\n      ),\n      result.errors[0],\n    )\n    return\n  }\n\n  const documents = (await Promise.resolve(normalizer(result))) || []\n\n  if (documents.length < 1)\n    reporter.warn(\n      msg(\n        `The query for index \"${name}\" returned no nodes. The index and store will be empty.`,\n      ),\n    )\n\n  const filteredDocuments = documents.filter(\n    (doc) => doc[ref] !== undefined && doc[ref] !== null,\n  )\n\n  const index = createIndexExport(\n    filteredDocuments,\n    pluginOptions,\n    gatsbyContext,\n  )\n  if (!index) return\n\n  const store = filteredDocuments.reduce((acc, doc) => {\n    acc[String(doc[ref])] = storeFields ? pick(doc, storeFields) : doc\n\n    return acc\n  }, {} as Store)\n\n  const nodeType = pascalCase(`${NodeType.LocalSearch} ${name}`)\n  const nodeId = createNodeId(name)\n\n  const node: LocalSearchNodeInput = {\n    id: nodeId,\n    name,\n    engine,\n    index,\n    store,\n    internal: {\n      type: nodeType,\n      contentDigest: createContentDigest({ index, store }),\n    },\n  }\n\n  createNode(node)\n}\n\nexport const createSchemaCustomization: NonNullable<\n  GatsbyNode['createSchemaCustomization']\n> = async (\n  gatsbyContext: CreateSchemaCustomizationArgs,\n  pluginOptions: PluginOptions,\n) => {\n  const { actions, schema, reporter, pathPrefix } = gatsbyContext\n  const { createTypes } = actions\n  const { name } = pluginOptions\n\n  const nodeType = pascalCase(`${NodeType.LocalSearch} ${name}`)\n\n  createTypes([\n    schema.buildObjectType({\n      name: nodeType,\n      fields: {\n        name: {\n          type: 'String!',\n          description: 'The name of the index.',\n        },\n        engine: {\n          type: 'String!',\n          description: 'The search engine used to create the index.',\n        },\n        index: {\n          type: 'String!',\n          description: 'The search index created using the selected engine.',\n        },\n        store: {\n          type: 'JSON!',\n          description:\n            'A JSON object used to map search results to their data.',\n        },\n        publicIndexURL: {\n          type: 'String!',\n          description:\n            \"Save the index to the site's static directory and return a public URL to it.\",\n          resolve: (node: LocalSearchNodeInput) => {\n            const filename = `${node.internal.contentDigest}.index.txt`\n\n            const publicPath = path.join(\n              process.cwd(),\n              'public',\n              'static',\n              filename,\n            )\n\n            if (!fs.existsSync(publicPath))\n              fs.writeFile(publicPath, node.index, (err) => {\n                if (err)\n                  reporter.error(\n                    msg(\n                      `Could not save the index for \"${name}\" to ${publicPath}`,\n                    ),\n                  )\n              })\n\n            return `${pathPrefix}/static/${filename}`\n          },\n        },\n        publicStoreURL: {\n          type: 'String!',\n          description:\n            \"Save the store to the site's static directory and return a public URL to it.\",\n          resolve: (node: LocalSearchNodeInput) => {\n            const filename = `${node.internal.contentDigest}.store.json`\n\n            const publicPath = path.join(\n              process.cwd(),\n              'public',\n              'static',\n              filename,\n            )\n\n            if (!fs.existsSync(publicPath))\n              fs.writeFile(publicPath, JSON.stringify(node.store), (err) => {\n                if (err)\n                  reporter.error(\n                    msg(\n                      `Could not save the store for \"${name}\" to ${publicPath}`,\n                    ),\n                  )\n              })\n\n            return `${pathPrefix}/static/${filename}`\n          },\n        },\n      },\n      interfaces: ['Node'],\n    }),\n  ])\n}\n"],"names":["NodeType","msg","input","gatsbyContext","pluginOptions","reporter","createNodeId","createContentDigest","createNode","actions","name","engine","ref","storeFields","store","normalizer","graphql","query","result","errors","Promise","resolve","documents","length","warn","filteredDocuments","filter","doc","index","indexFields","FlexSearch","create","engineOptions","forEach","docFieldValues","Object","values","pick","add","JSON","stringify","createFlexSearchIndexExport","fields","keys","lunr","this","field","_this","createLunrIndexExport","error","createIndexExport","reduce","acc","String","nodeType","pascalCase","LocalSearch","node","id","internal","type","contentDigest","schema","pathPrefix","createTypes","buildObjectType","description","publicIndexURL","filename","publicPath","path","join","process","cwd","fs","existsSync","writeFile","err","publicStoreURL","interfaces"],"mappings":"0EAaYA,wIAAZ,SAAYA,GACVA,4BADF,CAAYA,IAAAA,OCOZ,IAEMC,EAAM,SAACC,yCAAkDA,gCAmE7DC,EACAC,WAKEC,EAGEF,EAHFE,SACAC,EAEEH,EAFFG,aACAC,EACEJ,EADFI,oBAEMC,EADJL,EALFM,QAMMD,WAENE,EAMEN,EANFM,KACAC,EAKEP,EALFO,SAKEP,EAJFQ,IAAAA,aAnFgB,OAoFTC,EAGLT,EAHFU,MAEAC,EACEX,EADFW,mCAGmBC,EAXjBb,EAJFa,SAaEZ,EAFFa,sBAIIC,GAEN,IAAIA,EAAOC,8BAUcC,QAAQC,QAAQN,EAAWG,mBAA9CI,GAEFA,EAAUC,OAAS,GACrBlB,EAASmB,KACPvB,0BAC0BS,8DAI9B,IAAMe,EAAoBH,EAAUI,OAClC,SAACC,UAAQA,MAAAA,EAAIf,KAGTgB,EAxEkB,SACxBN,EACAlB,EACAD,OAEQE,EAAaF,EAAbE,SACAK,EAAiBN,EAAjBM,KAER,OAFyBN,EAAXO,QAGZ,IAAK,aACH,OAhD8B,SAClCW,EACAlB,SAEiEA,EAAzDQ,IAAAA,aARU,OAQgBiB,EAA+BzB,EAAtCwB,MAErBA,EAAQE,EAAWC,OAFwC3B,EAAlB4B,eAa/C,OATAV,EAAUW,QAAQ,SAACN,GACjB,IAAMO,EAAiBC,OAAOC,OAC5BP,EAAcQ,OAAKV,EAAKE,GAAeF,GAIzCC,EAAMU,IAAIX,EAAIf,GAAgB2B,KAAKC,UAAUN,MAGxCN,WA+BIa,CAA4BnB,EAAWlB,GAEhD,IAAK,OACH,OA/BwB,SAC5BkB,EACAlB,SAEkDA,EAA1CQ,IAAAA,aA5BU,OA4BgBiB,EAAgBzB,EAAvBwB,MAErBc,EACJb,MAAAA,EAAAA,EAAgBP,EAAUC,OAAS,EAAIY,OAAOQ,KAAKrB,EAAU,IAAM,GAE/DM,EAAQgB,EAAK,sBACjBC,KAAKjC,IAAIA,GACT8B,EAAOT,QAAQ,SAACa,UAAUC,EAAKD,MAAMA,KACrCxB,EAAUW,QAAQ,SAACN,UAAQoB,EAAKT,IAAIX,OAGtC,OAAOY,KAAKC,UAAUZ,GAgBXoB,CAAsB1B,EAAWlB,GAE1C,QACEC,EAAS4C,MACPhD,kCACkCS,yFAsD1BwC,CACZzB,EACArB,EACAD,GAEF,GAAKyB,EAAL,CAEA,IAAMd,EAAQW,EAAkB0B,OAAO,SAACC,EAAKzB,GAG3C,OAFAyB,EAAIC,OAAO1B,EAAIf,KAASC,EAAcwB,OAAKV,EAAKd,GAAec,EAExDyB,GACN,IAEGE,EAAWC,aAAcvD,EAASwD,gBAAe9C,GAGjD+C,EAA6B,CACjCC,GAHapD,EAAaI,GAI1BA,KAAAA,EACAC,OAAAA,EACAiB,MAAAA,EACAd,MAAAA,EACA6C,SAAU,CACRC,KAAMN,EACNO,cAAetD,EAAoB,CAAEqB,MAAAA,EAAOd,MAAAA,MAIhDN,EAAWiD,MAlDTpD,EAAS4C,MACPhD,EACE,8EAEFiB,EAAOC,OAAO,MA5BI,+EAgFtBhB,EACAC,WAEiB0D,EAAiC3D,EAAjC2D,OAAQzD,EAAyBF,EAAzBE,SAAU0D,EAAe5D,EAAf4D,WAC3BC,EAD0C7D,EAA1CM,QACAuD,YACAtD,EAASN,EAATM,KAEF4C,EAAWC,aAAcvD,EAASwD,gBAAe9C,UAEvDsD,EAAY,CACVF,EAAOG,gBAAgB,CACrBvD,KAAM4C,EACNZ,OAAQ,CACNhC,KAAM,CACJkD,KAAM,UACNM,YAAa,0BAEfvD,OAAQ,CACNiD,KAAM,UACNM,YAAa,+CAEftC,MAAO,CACLgC,KAAM,UACNM,YAAa,uDAEfpD,MAAO,CACL8C,KAAM,QACNM,YACE,2DAEJC,eAAgB,CACdP,KAAM,UACNM,YACE,+EACF7C,QAAS,SAACoC,GACR,IAAMW,EAAcX,EAAKE,SAASE,2BAE5BQ,EAAaC,EAAKC,KACtBC,QAAQC,MACR,SACA,SACAL,GAaF,OAVKM,EAAGC,WAAWN,IACjBK,EAAGE,UAAUP,EAAYZ,EAAK7B,MAAO,SAACiD,GAChCA,GACFxE,EAAS4C,MACPhD,mCACmCS,UAAY2D,MAK7CN,aAAqBK,IAGnCU,eAAgB,CACdlB,KAAM,UACNM,YACE,+EACF7C,QAAS,SAACoC,GACR,IAAMW,EAAcX,EAAKE,SAASE,4BAE5BQ,EAAaC,EAAKC,KACtBC,QAAQC,MACR,SACA,SACAL,GAaF,OAVKM,EAAGC,WAAWN,IACjBK,EAAGE,UAAUP,EAAY9B,KAAKC,UAAUiB,EAAK3C,OAAQ,SAAC+D,GAChDA,GACFxE,EAAS4C,MACPhD,mCACmCS,UAAY2D,MAK7CN,aAAqBK,KAIrCW,WAAY,CAAC,8BAxFmB"}